"use strict";(self.webpackChunksudeeparyan_knowledgebase=self.webpackChunksudeeparyan_knowledgebase||[]).push([[118],{92403:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>p,frontMatter:()=>r,metadata:()=>a,toc:()=>c});var s=t(74848),o=t(28453);const r={},i=void 0,a={id:"RAG360/Evaluation/Metrics/Groundedness",title:"Groundedness",description:"Is the response supported by the context?",source:"@site/docs/RAG360/Evaluation/Metrics/Groundedness.md",sourceDirName:"RAG360/Evaluation/Metrics",slug:"/RAG360/Evaluation/Metrics/Groundedness",permalink:"/docs/RAG360/Evaluation/Metrics/Groundedness",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"ragSidebar",previous:{title:"Context Relevance",permalink:"/docs/RAG360/Evaluation/Metrics/Context Relevance"},next:{title:"Answer Relevance",permalink:"/docs/RAG360/Evaluation/Metrics/Answer Relevance"}},d={},c=[{value:"Is the response supported by the context?",id:"is-the-response-supported-by-the-context",level:4}];function u(e){const n={admonition:"admonition",code:"code",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.admonition,{type:"info",children:[(0,s.jsx)(n.h4,{id:"is-the-response-supported-by-the-context",children:"Is the response supported by the context?"}),(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"After the context is retrieved, it is then formed into an answer by an LLM.\nLLMs are often prone to stray from the facts provided, exaggerating or\nexpanding to a correct-sounding answer."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"To verify the groundedness of our application, we can separate the response\ninto individual claims and independently search for evidence that supports\neach within the retrieved context."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:'"Usage"'})," part in function documentation tells how to define the\nFeedback Function for Groundedness."]}),"\n"]}),"\n"]})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'LLM_GROUNDEDNESS_FULL_SYSTEM = """You are a INFORMATION OVERLAP classifier providing the overlap of information between a SOURCE and STATEMENT.\nFor every sentence in the statement, please answer with this template:\n\nTEMPLATE:\nStatement Sentence: <Sentence>,\nSupporting Evidence: <Choose the exact unchanged sentences in the source that can answer the statement, if nothing matches, say NOTHING FOUND>\nScore: <Output a number between 0-10 where 0 is no information overlap and 10 is all information is overlapping>\n"""\n\nLLM_GROUNDEDNESS_FULL_PROMPT = """Give me the INFORMATION OVERLAP of this SOURCE and STATEMENT.\n\nSOURCE: {premise}\n\nSTATEMENT: {hypothesis}\n"""\n\ndef groundedness_measure_with_cot_reasons(\n        self, source: str, statement: str\n    ) -> Tuple[float, dict]:\n        """\n        A measure to track if the source material supports each sentence in the statement using an LLM provider.\n\n        The LLM will process the entire statement at once, using chain of thought methodology to emit the reasons.\n\n        Usage on RAG Contexts:\n        from trulens_eval import Feedback\n        from trulens_eval.feedback import Groundedness\n        from trulens_eval.feedback.provider.openai import OpenAI\n        grounded = feedback.Groundedness(groundedness_provider=OpenAI())\n\n\n        f_groundedness = feedback.Feedback(grounded.groundedness_measure_with_cot_reasons).on(\n            Select.Record.app.combine_documents_chain._call.args.inputs.input_documents[:].page_content # See note below\n        ).on_output().aggregate(grounded.grounded_statements_aggregator)\n        The `on(...)` selector can be changed. See [Feedback Function Guide : Selectors](https://www.trulens.org/trulens_eval/feedback_function_guide/#selector-details)\n\n\n        Args:\n            source (str): The source that should support the statement\n            statement (str): The statement to check groundedness\n\n        Returns:\n            Tuple[float, dict]: A measure between 0 and 1, where 1 means each sentence is grounded in the source.\n        """\n        groundedness_scores = {}\n        if not isinstance(self.groundedness_provider, LLMProvider):\n            raise AssertionError(\n                "Only LLM providers are supported for groundedness_measure_with_cot_reasons."\n            )\n        else:\n            reason = self.groundedness_provider._groundedness_doc_in_out(\n                source, statement\n            )\n            i = 0\n            for line in reason.split(\'\\n\'):\n                if "Score" in line:\n                    groundedness_scores[f"statement_{i}"\n                                       ] = re_0_10_rating(line) / 10\n                    i += 1\n        return groundedness_scores, {"reasons": reason}\n\ndef _groundedness_doc_in_out(self, premise: str, hypothesis: str) -> str:\n        """\n        An LLM prompt using the entire document for premise and entire statement\n        document for hypothesis.\n\n        Args:\n            premise (str): A source document\n            hypothesis (str): A statement to check\n\n        Returns:\n            str: An LLM response using a scorecard template\n        """\n        assert self.endpoint is not None, "Endpoint is not set."\n\n        return self.endpoint.run_in_pace(\n            func=self._create_chat_completion,\n            prompt=str.format(prompts.LLM_GROUNDEDNESS_FULL_SYSTEM,) +\n            str.format(\n                prompts.LLM_GROUNDEDNESS_FULL_PROMPT,\n                premise=premise,\n                hypothesis=hypothesis\n            )\n        )\n        ```\n'})})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var s=t(96540);const o={},r=s.createContext(o);function i(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);