"use strict";(self.webpackChunksudeeparyan_knowledgebase=self.webpackChunksudeeparyan_knowledgebase||[]).push([[8957],{12601:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var t=n(74848),s=n(28453);const o={},a=void 0,i={id:"RAG360/Evaluation/Metrics/Custom Metric",title:"Custom Metric",description:"Custom Metric Creation Workflow in Trulens",source:"@site/docs/RAG360/Evaluation/Metrics/Custom Metric.md",sourceDirName:"RAG360/Evaluation/Metrics",slug:"/RAG360/Evaluation/Metrics/Custom Metric",permalink:"/docs/RAG360/Evaluation/Metrics/Custom Metric",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"ragSidebar",previous:{title:"Metrics",permalink:"/docs/category/metrics"},next:{title:"System Metrics vs Module Metrics",permalink:"/docs/RAG360/Evaluation/Metrics/System Metrics vs Module Metrics"}},c={},l=[{value:"Custom Metric Creation Workflow in Trulens",id:"custom-metric-creation-workflow-in-trulens",level:2},{value:"Prerequisite Knowledge",id:"prerequisite-knowledge",level:3},{value:"Procedure",id:"procedure",level:3},{value:"Reference",id:"reference",level:3},{value:"Custom Metrics in Astro Chat Assistant",id:"custom-metrics-in-astro-chat-assistant",level:2},{value:"Custom Metrics in Chat Assistant",id:"custom-metrics-in-chat-assistant",level:3},{value:"Extended Custom Metric Class from LLM Provider",id:"extended-custom-metric-class-from-llm-provider",level:3},{value:"Trulens Recorder Implementation",id:"trulens-recorder-implementation",level:3},{value:"Feedback Definitions and Recording",id:"feedback-definitions-and-recording",level:3},{value:"Custom Metrics in Datasheet Assistant",id:"custom-metrics-in-datasheet-assistant",level:2},{value:"Metrics Definition with Prompts",id:"metrics-definition-with-prompts",level:3}];function u(e){const r={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",ol:"ol",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.h2,{id:"custom-metric-creation-workflow-in-trulens",children:"Custom Metric Creation Workflow in Trulens"}),"\n",(0,t.jsx)(r.h3,{id:"prerequisite-knowledge",children:"Prerequisite Knowledge"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsx)(r.li,{children:"Feedback Functions in Trulens"}),"\n",(0,t.jsx)(r.li,{children:"Providers in Trulens"}),"\n",(0,t.jsx)(r.li,{children:"Records in Trulens"}),"\n",(0,t.jsx)(r.li,{children:"Selectors in Trulens"}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"procedure",children:"Procedure"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsx)(r.li,{children:"Create a python class that inherits the desired provider(OpenAI or\r\nAzureOpenAI) class."}),"\n",(0,t.jsx)(r.li,{children:"In the class, define a function that takes inputs and provides any float\r\nvalue between 0 to 1 as the output."}),"\n",(0,t.jsx)(r.li,{children:"The function can be purely logical or can use AI to come up with the value of\r\nthe metric between 0 to 1."}),"\n",(0,t.jsx)(r.li,{children:"Example of a purely logical function/metric - Identifying lint errors in a\r\ncode snippet using python libraries and producing a score based on the number\r\nof errors and the number of lines in the code."}),"\n"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-js",children:'def _lint_check_cpp(self, file_path: str):\r\n    import subprocess\r\n\r\n    result = subprocess.run(\r\n        ["poetry", "run", "cpplint", file_path],\r\n        stdout=subprocess.PIPE,\r\n        stderr=subprocess.PIPE,\r\n    )\r\n    number_of_errors = result.stdout.decode("utf-8").split("\\n")\r\n    error_number = 0\r\n    for line in number_of_errors:\r\n        if "Total errors found" in line:\r\n            errors = int(line.split(":")[1].strip())\r\n            if errors == 0:\r\n                error_number = 0\r\n            else:\r\n                error_number = errors\r\n    error_list = result.stderr.decode("utf-8")\r\n    return error_number, error_list\r\n\r\ndef lint_check(self, candidate: str, language: str):\r\n    if language == "cpp":\r\n        with open(TEST_CPP_FILE_PATH, "w") as f:\r\n            f.write(candidate)\r\n        result = self._lint_check_cpp(TEST_CPP_FILE_PATH)\r\n        if result[0] == 0:\r\n            return 1.0, {"reason": "No linting errors found"}\r\n        else:\r\n            number_of_lines = len(candidate.split("\\n"))\r\n            linting_score = 1 - (result[0] / number_of_lines)\r\n            if linting_score < 0:\r\n                linting_score = 0.0\r\n            return linting_score, {\r\n                "reason": (\r\n                    f"{\'Number of Errors: \' + str(result[0])}\\n"\r\n                    f"{\'List of Errors: \' + str(result[1])}"\r\n                )\r\n            }\n'})}),"\n",(0,t.jsxs)(r.ol,{start:"5",children:["\n",(0,t.jsx)(r.li,{children:"Example of using AI to come up with scores: Calculating how accurate a\r\ngenerated search query is with respect to the actual query."}),"\n"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-js",children:'SEARCH_QUERY_ACCURACY_TEMPLATE = """\r\n\r\nSystem:\r\nYou are a SEARCH QUERY ACCURACY classifier providing the accuracy of the SEARCH QUERY formed by combination of USER QUESTION and CHAT HISTORY.\r\nYou will be provided with a USER QUESTION, CHAT HISTORY and a SEARCH QUERY.\r\nYour task is to evaluate If the SEARCH QUERY accurately reflects the USER QUESTION and includes all necessary details to be understood on its own. This includes appropriately filling in any gaps left by an incomplete USER QUESTION using the CHAT HISTORY.\r\nPurpose of the SEARCH QUERY is to retrieve the desired information from the database related to the USER QUESTION.\r\n\r\nUSER QUESTION (mentioned within the triple quotes below):\r\n```{user_question}```\r\n\r\nCHAT HISTORY (mentioned within the triple quotes below):\r\n```{chat_history}```\r\n\r\nSEARCH QUERY (mentioned within the triple quotes below):\r\n```{search_query}```\r\n\r\nPlease answer using the entire template below.\r\n\r\nTEMPLATE:\r\nObservation: <The observation on the criteria for the SEARCH QUERY ACCURACY evaluation.>\r\nScore: <The score 0-10 based on the given criteria>\r\nSupporting Evidence: <Provide your reasons for scoring based on the ACCURACY of the SEARCH QUERY. Tie it back to the evaluation being completed.>\r\n"""\r\ndef search_query_accuracy_with_cot_reasons(\r\n    self, user_question: str, chat_history: list[str], search_query: str\r\n) -> float:\r\n    """Get the accuracy score for the search query generated\r\n\r\n    Usage:\r\n        search_query_accuracy_feedback = (\r\n            Feedback(provider.search_query_accuracy_with_cot_reasons, name="Search Query Accuracy")\r\n            .on(user_question=Select.RecordCalls.query.args["question"])\r\n            .on(chat_history=Select.RecordCalls.query.args["chat_history"])\r\n            .on(search_query=Select.RecordCalls.get_search_query.rets)\r\n        )\r\n\r\n\r\n        Args:\r\n            user_question (str): The user question for which the query is being generated\r\n            chat_history (list[str]): previous chat history\r\n            search_query (str): The search query generated by the system\r\n\r\n        Returns:\r\n            float: A value between 0 and 1. 0 being "not accurate" and 1 being "mostly accurate".\r\n    """\r\n\r\n    system_prompt = str.format(\r\n        SEARCH_QUERY_ACCURACY_TEMPLATE,\r\n        user_question=user_question,\r\n        chat_history=chat_history,\r\n        search_query=search_query,\r\n    )\r\n    return self.generate_score_and_reasons(system_prompt)\n'})}),"\n",(0,t.jsx)(r.admonition,{type:"tip",children:(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"The format of output given in the prompt is important because Trulens will\r\nhelp in visualising the output given for 'Supporting Evidence' by the LLM."}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"The generate_score_and_reasons() function will help in parsing the generated\r\ntext output of LLM, store the metrics and reasons that will help in\r\nvisualizing them in the dashboard later."}),"\n"]}),"\n"]})}),"\n",(0,t.jsxs)(r.ol,{start:"3",children:["\n",(0,t.jsx)(r.li,{children:"Once we have a function that will provide us a score, we can implement it in\r\nevaluation by wrapping it as a Feedback Function."}),"\n",(0,t.jsx)(r.li,{children:"Feedback Functions are individual metrics in Trulens terms."}),"\n",(0,t.jsx)(r.li,{children:"Feedback Function definition for the above examples:"}),"\n"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-js",children:'search_query_accuracy_feedback = Feedback(\r\n  provider.search_query_accuracy_with_cot_reasons,\r\n  (name = "Search Query Accuracy"),\r\n)\r\n  .on((user_question = Select.RecordCalls.query.args["question"]))\r\n  .on((chat_history = Select.RecordCalls.query.args["chat_history"]))\r\n  .on((search_query = Select.RecordCalls.get_search_query.rets));\r\n\r\nlint_check = Feedback(provider.lint_check, (name = "Lint Check"))\r\n  .on_output()\r\n  .on(Select.RecordCalls.get_candidate.args["language"]);\n'})}),"\n",(0,t.jsxs)(r.admonition,{type:"tip",children:[(0,t.jsx)(r.mdxAdmonitionTitle,{}),(0,t.jsx)(r.p,{children:"Note that the arguments to the python metric/function we defined will be\r\nmapped using the on() method and Select object in Trulens which will make use of\r\nattributes of the Record object."})]}),"\n",(0,t.jsxs)(r.ol,{start:"9",children:["\n",(0,t.jsx)(r.li,{children:"Now the custom metric can be calculated just as any inbuilt Trulens metric."}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"reference",children:"Reference"}),"\n",(0,t.jsx)(r.admonition,{type:"info",children:(0,t.jsx)(r.p,{children:(0,t.jsx)(r.a,{href:"https://www.trulens.org/trulens_eval/evaluation/feedback_implementations/custom_feedback_functions/",children:"Reference"})})}),"\n",(0,t.jsx)(r.h2,{id:"custom-metrics-in-astro-chat-assistant",children:"Custom Metrics in Astro Chat Assistant"}),"\n",(0,t.jsx)(r.h3,{id:"custom-metrics-in-chat-assistant",children:"Custom Metrics in Chat Assistant"}),"\n",(0,t.jsxs)("table",{class:"table-size-for-cloud-services",children:[(0,t.jsx)("thead",{children:(0,t.jsxs)("tr",{children:[(0,t.jsx)("th",{children:"Factors"}),(0,t.jsx)("th",{children:"Description"})]})}),(0,t.jsxs)("tbody",{children:[(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{class:"custom-header",children:"Valid Number of Function Arguments while using Skills"}),(0,t.jsx)("td",{children:"Validate if the proper number of arguments were provided for the selected skill."})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{class:"custom-header",children:"Correctness of Skill/Function Call made by the Orchestrator"}),(0,t.jsx)("td",{children:"Check if the choice of skill made by the Orchestrator is the desired skill to answer the given query."})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{class:"custom-header",children:"Guideline Adherence of the Response"}),(0,t.jsx)("td",{children:"Check if the response generated by LLM follows the guidelines provided in the System Prompt during synthesis."})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{class:"custom-header",children:"Average Moderation Score from OpenAI for the response"}),(0,t.jsx)("td",{children:"Average of scores provided by Moderation [Hate, Violence, and Harassment/Threatening] API of OpenAI."})]})]})]}),"\n",(0,t.jsx)(r.h3,{id:"extended-custom-metric-class-from-llm-provider",children:"Extended Custom Metric Class from LLM Provider"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-js",children:'class FunctionsEvaluation(Provider):\r\n    provider: Provider\r\n\r\n    def __init__(self, provider: Provider, **kwargs):\r\n        """Initialize the FunctionsEvaluation"""\r\n        super().__init__(provider=provider, **kwargs)\r\n\r\n    def evaluate_function_arguments(self, function_arguments, skill_arguments):\r\n        """Evaluate the function arguments"""\r\n        correct_function_arguments = 0\r\n        for function in function_arguments:\r\n            function_name = function["function"]["name"]\r\n            function_args = list(json.loads(function["function"]["arguments"]).keys())\r\n            if function_args == skill_arguments[function_name]:\r\n                correct_function_arguments += 1\r\n        if correct_function_arguments == len(function_arguments) and correct_function_arguments > 0:\r\n            return 1.0\r\n        return 0.0\r\n\r\n    def evaluate_function_choice(self, query, function_arguments, skill_arguments):\r\n        """Evaluate the function choice"""\r\n        correctness_scores = []\r\n        if len(function_arguments) == 0:\r\n            return [\'{"Correctness": 0}\']\r\n        for function in function_arguments:\r\n            function_name = function["function"]["name"]\r\n            correctness_scores.append(\r\n                self.provider._create_chat_completion(\r\n                    prompt=f"{FUNCTION_CHOICE_EVAL_SYSTEM_PROMPT}{FUNCTION_CHOICE_EVALUATION_PROMPT.format(query=query, function_description=skill_arguments[function_name])}"  # noqa\r\n                )\r\n            )\r\n        return correctness_scores\r\n\r\n    def evaluate_function_choice_with_cot_reasons(self, query, function_arguments, skill_arguments):\r\n        """Evaluate the function choice with cot reasons"""\r\n        correctness_score = []\r\n        reason = self.evaluate_function_choice(query, function_arguments, skill_arguments)\r\n        for function in reason:\r\n            function = json.loads(function)\r\n            correctness_score.append(re_0_10_rating(str(function["Correctness"])) / 10)\r\n        return np.mean(correctness_score), {"reason": reason}\r\n\r\n    def evaluate_response_guideline_adherence(self, query, response, function_responses):\r\n        """Evaluate the response guideline adherence"""\r\n        adherence_scores = []\r\n        reasons = []\r\n        mean = 0.0\r\n        if len(function_responses) > 0:\r\n            context = "\\n".join(function_responses)\r\n        else:\r\n            context = "No Context"\r\n        for guideline, criterion in zip(guidelines, criteria):\r\n\r\n            reason = self.provider._create_chat_completion(\r\n                prompt=f"{GUIDELINES_ADHERENCE_EVAL_SYSTEM_PROMPT}{GUIDELINE_ADHERENCE_EVALUATION_PROMPT.format(query=query, response=response, context=context, criteria=criterion,guideline=guideline,)}",  # noqa\r\n            )\r\n            reason = json.loads(reason)\r\n            reasons.append(\r\n                {\r\n                    "Guideline": guideline,\r\n                    "CriterionCompliance": reason["CriterionCompliance"],\r\n                    "Feedback": reason["Feedback"],\r\n                    "Adherence": reason["Adherence"],\r\n                }\r\n            )\r\n            if reason["Adherence"] == "YES":\r\n                adherence_scores.append(1)\r\n            elif reason["Adherence"] == "NO":\r\n                adherence_scores.append(0)\r\n\r\n        reasons_string = "\\n".join([json.dumps(reason) for reason in reasons])\r\n        if len(adherence_scores) > 0:\r\n            mean = round(np.mean(adherence_scores), 2)\r\n        return mean, reasons_string\r\n\r\n    def evaluate_guidelines_adherence_with_cot_reasons(self, query, response, function_responses):\r\n        """Evaluate the function choice with cot reasons"""\r\n        score, reason = self.evaluate_response_guideline_adherence(\r\n            query, response, function_responses\r\n        )\r\n        return float(score), {"reason": reason}\r\n\r\n    def evaluate_moderation(self, response):\r\n        """Evaluate the moderation hate"""\r\n        score = {}\r\n        score["ModerationHate"] = round(1 - self.provider.moderation_hate(response), 2)\r\n        score["ModerationViolence"] = round(1 - self.provider.moderation_violence(response), 2)\r\n        score["ModerationHarassmentThreatening"] = round(\r\n            1 - self.provider.moderation_harassment_threatening(response), 2\r\n        )\r\n        mean_score = round(np.mean(list(score.values())), 2)\r\n        return mean_score, {"reason": score}\r\n\n'})}),"\n",(0,t.jsx)(r.h3,{id:"trulens-recorder-implementation",children:"Trulens Recorder Implementation"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-js",children:'class OrchestratorTest:\r\n    """Class for TruCustomApp"""\r\n\r\n    async def get_answer(self, orchestrator, task):\r\n        return await orchestrator.run(task)\r\n\r\n    @instrument\r\n    def query(self, question: str, chat_history: List[str]) -> str:\r\n        """Get the answer to the question"""\r\n        chatHistory: List[str] = chat_history\r\n        ignoredDataSources: List[str] = []\r\n        metaData: TaskMetaData = TaskMetaData()\r\n        attachments: List[Attachment] = []\r\n        additional_input: TaskAdditionalInput = TaskAdditionalInput(\r\n            chatHistory=chatHistory,\r\n            ignoredDataSources=ignoredDataSources,\r\n            metaData=metaData,\r\n            attachments=attachments,\r\n        )\r\n\r\n        task = TaskRequestBody(\r\n            input=question,\r\n            additional_input=additional_input,  # noqa\r\n        )\r\n\r\n        # Create an instance of OpenAIFunctionCalling\r\n        orchestrator = get_orchestrator_from_config(debug_mode=True)\r\n        result = asyncio.run(self.get_answer(orchestrator, task))\r\n        _ = self.get_function_args(orchestrator.performance_evaluation_log)\r\n        _ = self.get_skills_responses(orchestrator.performance_evaluation_log)\r\n        _ = self.get_skill_args(\r\n            orchestrator.performance_evaluation_log["skill_required_arguments_schema"]\r\n        )\r\n        _ = self.get_skill_descriptions(\r\n            orchestrator.performance_evaluation_log["skill_required_arguments_schema"]\r\n        )\r\n        return result.answer\n'})}),"\n",(0,t.jsx)(r.h3,{id:"feedback-definitions-and-recording",children:"Feedback Definitions and Recording"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-js",children:'f_open_ai = fOpenAI(\r\n    model_engine=os.getenv("OPEN_AI_CHAT_MODEL"),\r\n    api_key=os.getenv("OPEN_AI_API_KEY"),\r\n)\r\nfn_eval = FunctionsEvaluation(provider=f_open_ai)\r\nf_fn_args_eval = (\r\n   Feedback(\r\n       fn_eval.evaluate_function_arguments,\r\n       name="Function Arguments Evaluation",\r\n   )\r\n   .on(Select.RecordCalls.get_function_args.rets)\r\n   .on(Select.RecordCalls.get_skill_args.rets)\r\n)  # instantiate feedback function\r\nf_moderation = Feedback(fn_eval.evaluate_moderation, name="Moderation Evaluation").on_output()\r\ngrounded = Groundedness(groundedness_provider=f_open_ai)\r\n# Define a groundedness feedback function\r\nf_groundedness = (\r\n    Feedback(grounded.groundedness_measure_with_cot_reasons, name="Groundedness")\r\n    .on(Select.RecordCalls.get_skills_responses.rets)\r\n    .on_output()\r\n    .aggregate(grounded.grounded_statements_aggregator)\r\n)\r\nf_qa_relevance = (\r\n    Feedback(f_open_ai.relevance_with_cot_reasons, name="Answer Relevance")\r\n    .on_input()\r\n    .on_output()\r\n)\r\nf_fn_choice_eval = (\r\n    Feedback(\r\n       fn_eval.evaluate_function_choice_with_cot_reasons,\r\n       name="Function Choice Evaluation",\r\n    )\r\n    .on_input()\r\n    .on(Select.RecordCalls.get_function_args.rets)\r\n    .on(Select.RecordCalls.get_skill_descriptions.rets)\r\n)\r\nf_fn_guideline_adherence = (\r\n    Feedback(\r\n        fn_eval.evaluate_guidelines_adherence_with_cot_reasons,\r\n        name="Response Guideline Adherence",\r\n     )\r\n     .on_input()\r\n     .on_output()\r\n     .on(Select.RecordCalls.get_skills_responses.rets)\r\n)\r\n\r\nwith tru_custom_app as recording:\r\n    orchestrator.query(question, chat)\r\nrecord = recording.get()\r\nfeedback_results = tru.run_feedback_functions(\r\n    record=record,\r\n    feedback_functions=[\r\n        f_fn_args_eval,\r\n        f_groundedness,\r\n        f_qa_relevance,\r\n        f_fn_choice_eval,\r\n        f_fn_guideline_adherence,\r\n        f_moderation,\r\n   ],\r\n)\r\ntru.add_feedbacks(feedback_results)\r\n\n'})}),"\n",(0,t.jsx)(r.h2,{id:"custom-metrics-in-datasheet-assistant",children:"Custom Metrics in Datasheet Assistant"}),"\n",(0,t.jsxs)("table",{class:"table-size-for-cloud-services",children:[(0,t.jsx)("thead",{children:(0,t.jsxs)("tr",{children:[(0,t.jsx)("th",{children:"Metrics"}),(0,t.jsx)("th",{children:"Description"})]})}),(0,t.jsxs)("tbody",{children:[(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{class:"custom-header",children:"Expected Answer Match or Conceptual Information Overlap"}),(0,t.jsx)("td",{children:"This metric compares the overlap of information between a source and a statement. It returns a score between 0 and 1, indicating the degree of overlap."})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{class:"custom-header",children:"Conversation Starter Presence"}),(0,t.jsx)("td",{children:"This metric evaluates the presence of conversation starters in a given text. It returns a score between 0 and 1, indicating the presence and absence of conversation starters respectively."})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{class:"custom-header",children:"Search Query Accuracy"}),(0,t.jsx)("td",{children:"This metric evaluates the accuracy of a search query generated based on a user question and chat history. It returns a score between 0 and 1, indicating the accuracy of the search query."})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{class:"custom-header",children:"Search Query Conciseness"}),(0,t.jsx)("td",{children:"This metric evaluates the conciseness of a search query generated based on a user question and chat history. It returns a score between 0 and 1, indicating the conciseness of the search query."})]})]})]}),"\n",(0,t.jsx)(r.h3,{id:"metrics-definition-with-prompts",children:"Metrics Definition with Prompts"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-js",children:'COMPARE_ANSWER_TEMPLATE = """\r\nSystem:\r\nYou are an INFORMATION / CONCEPTUAL OVERLAP classifier providing the overlap of information between a SOURCE and STATEMENT.\r\nUse the \'Conceptual Overlap\' model to compare the given actual answer with given expected answer to see how much does actual answer matches.\r\nRespond only as a number between 0-10 where 0 is no information overlap and 10 is all information is overlapping\r\n\r\nA few additional scoring guidelines:\r\n\r\n- Long RESPONSES should score equally well as short RESPONSES.\r\n\r\n- Score should increase as the RESPONSE contains more information from the EXPECTED RESPONSE.\r\n\r\n- RESPONSE that does not contain any overlapping information from the EXPECTED RESPONSE should get a score of 0.\r\n\r\n- RESPONSE that contains some overlapping information from the EXPECTED RESPONSE should get as score of 2, 3, or 4. Higher score indicates more overlapping informations.\r\n\r\n- RESPONSE that contains more overlapping information from the EXPECTED RESPONSE should get a score between a 5, 6, 7 or 8. Higher score indicates more overlapping informations.\r\n\r\n- RESPONSE that almost contains most of the overlapping information from the EXPECTED RESPONSE should get a score of 9 or 10.\r\n\r\n- RESPONSE must contain all informations present in the EXPECTED RESPONSE to get a score of 10.\r\n\r\n- RESPONSE might contain additional information that is not present in the EXPECTED RESPONSE. This should not affect the score.\r\n\r\n- RESPONSE that confidently FALSE should get a score of 0.\r\n\r\n- RESPONSE that is only seemingly MATCH should get a score of 0.\r\n\r\n\r\n- Never elaborate.\r\n\r\nEXPECTED RESPONSE (mentioned within the triple quotes below):\r\n```{expected_answer}```\r\n\r\nRESPONSE (mentioned within the triple quotes below):\r\n```{actual_answer}```\r\n\r\nScore: """\r\n\r\n\r\nCONVERSATIONAL_WORDS_PRESENCE_TEMPLATE = """\r\nSystem:\r\nYou are a CONVERSATION WORDS PRESENCE classifier providing the absence of CONVERSATION WORDS in the given TEXT.\r\nYou will be provided with a TEXT.\r\nYour task is to evaluate the absence of CONVERSATION WORDS in the TEXT.\r\nConversation starters are informal phrases or questions that are used to initiate or continue a conversation. They are not directly related to the main topic of the text.\r\n\r\nPlease follow these guidelines for your evaluation:\r\n1. Give a score of 0 if the SEARCH QUERY contains informal language, conversation starters.\r\n2. Give a score of 10 if the SEARCH QUERY does not contain informal language, conversation starters.\r\n\r\nTEXT (mentioned within the triple quotes below):\r\n```{text}```\r\n\r\nPlease answer using the entire template below.\r\n\r\nTEMPLATE:\r\nObservation: <The observation on the absence of CONVERSATION WORDS in the TEXT.>\r\nScore: <The score 0-10 based on the absence of CONVERSATION WORDS.>\r\nSupporting Evidence: <Provide your reasons for scoring based on the absence of CONVERSATION WORDS. Tie it back to the evaluation being completed.>\r\n"""\r\n\r\nSEARCH_QUERY_ACCURACY_TEMPLATE = """\r\n\r\nSystem:\r\nYou are a SEARCH QUERY ACCURACY classifier providing the accuracy of the SEARCH QUERY formed by combination of USER QUESTION and CHAT HISTORY.\r\nYou will be provided with a USER QUESTION, CHAT HISTORY and a SEARCH QUERY.\r\nYour task is to evaluate If the SEARCH QUERY accurately reflects the USER QUESTION and includes all necessary details to be understood on its own. This includes appropriately filling in any gaps left by an incomplete USER QUESTION using the CHAT HISTORY.\r\nPurpose of the SEARCH QUERY is to retrieve the desired information from the database related to the USER QUESTION.\r\n\r\nUSER QUESTION (mentioned within the triple quotes below):\r\n```{user_question}```\r\n\r\nCHAT HISTORY (mentioned within the triple quotes below):\r\n```{chat_history}```\r\n\r\nSEARCH QUERY (mentioned within the triple quotes below):\r\n```{search_query}```\r\n\r\nPlease answer using the entire template below.\r\n\r\nTEMPLATE:\r\nObservation: <The observation on the criteria for the SEARCH QUERY ACCURACY evaluation.>\r\nScore: <The score 0-10 based on the given criteria>\r\nSupporting Evidence: <Provide your reasons for scoring based on the ACCURACY of the SEARCH QUERY. Tie it back to the evaluation being completed.>\r\n"""\r\n\r\nSEARCH_QUERY_CONCISENESS_TEMPLATE = """\r\n\r\nSystem:\r\nYou are a SEARCH QUERY CONCISENESS classifier providing the conciseness of the SEARCH QUERY formed by combination of USER QUESTION and CHAT HISTORY.\r\nYou will be provided with a USER QUESTION, CHAT HISTORY and a SEARCH QUERY.\r\nYour task is to evaluate If the SEARCH QUERY is free from irrelevant or extraneous information, focusing solely on what is necessary to answer the USER QUESTION effectively.\r\nPurpose of the SEARCH QUERY is to retrieve the desired information from the database related to the USER QUESTION.\r\n\r\nUSER QUESTION (mentioned within the triple quotes below):\r\n```{user_question}```\r\n\r\nCHAT HISTORY (mentioned within the triple quotes below):\r\n```{chat_history}```\r\n\r\nSEARCH QUERY (mentioned within the triple quotes below):\r\n```{search_query}```\r\n\r\nPlease answer using the entire template below.\r\n\r\nTEMPLATE:\r\nObservation: <The observation on the criteria for the SEARCH QUERY CONCISENESS evaluation.>\r\nScore: <The score 0-10 based on the given criteria>\r\nSupporting Evidence: <Provide your reasons for scoring based on the CONCISENESS of the SEARCH QUERY. Tie it back to the evaluation being completed.>\r\n"""\r\n\r\n\r\nclass ExtendedOpenAIProvider(OpenAI):\r\n\r\n    def compare_using_conceptual_overlap_with_cot_reasons(\r\n        self, expected_answer: str, actual_answer: str\r\n    ) -> float:\r\n        """Get the comparision feedback using conceptual overlap\r\n        Uses chat completion Model. Also uses chain of\r\n        thought methodology and emits the reasons.\r\n\r\n        Usage:\r\n            ``` python\r\n            feedback = (\r\n                Feedback(provider.compare_using_conceptual_overlap_with_cot_reasons)\r\n                .on(expected_answer=Select.RecordCalls.query.args["expected_answer"])\r\n                .on(actual_answer=Select.RecordCalls.query.rets)\r\n            )\r\n\r\n        Args:\r\n            expected_answer (str): The expected answer for the current question in test\r\n            actual_answer (str): The actual answer from the assistant\r\n\r\n        Returns:\r\n            float: A value between 0 and 1. 0 being "not same" and 1 being "mostly same".\r\n        """\r\n\r\n        system_prompt = str.format(\r\n            COMPARE_ANSWER_TEMPLATE,\r\n            expected_answer=expected_answer,\r\n            actual_answer=actual_answer,\r\n        )\r\n        system_prompt = system_prompt.replace("Score:", prompts.COT_REASONS_TEMPLATE)\r\n        return self.generate_score_and_reasons(system_prompt)\r\n\r\n    def chat_conversation_presence_with_cot_reasons(self, text: str) -> float:\r\n        """Get the presence of conversation starters in the text\r\n\r\n        Usage:\r\n            ```python\r\n            conversation_starters_feedback = (\r\n                Feedback(provider.chat_conversation_presence_with_cot_reasons, name="Conversation Starters")\r\n                .on(text=Select.RecordCalls.get_search_query.rets)\r\n            )\r\n\r\n        Args:\r\n            text (str): The text to be evaluated for conversation starters\r\n\r\n        Returns:\r\n            float: A value between 0 and 1. 0 being "no conversation starters" and 1 being "conversation starters present".\r\n        """\r\n\r\n        system_prompt = str.format(\r\n            CONVERSATIONAL_WORDS_PRESENCE_TEMPLATE,\r\n            text=text,\r\n        )\r\n        return self.generate_score_and_reasons(system_prompt)\r\n\r\n    def search_query_accuracy_with_cot_reasons(\r\n        self, user_question: str, chat_history: list[str], search_query: str\r\n    ) -> float:\r\n        """Get the accuracy score for the search query generated\r\n\r\n        Usage:\r\n            ```python\r\n            search_query_accuracy_feedback = (\r\n                Feedback(provider.search_query_accuracy_with_cot_reasons, name="Search Query Accuracy")\r\n                .on(user_question=Select.RecordCalls.query.args["question"])\r\n                .on(chat_history=Select.RecordCalls.query.args["chat_history"])\r\n                .on(search_query=Select.RecordCalls.get_search_query.rets)\r\n            )\r\n\r\n        Args:\r\n            user_question (str): The user question for which the query is being generated\r\n            chat_history (list[str]): previous chat history\r\n            search_query (str): The search query generated by the system\r\n\r\n        Returns:\r\n            float: A value between 0 and 1. 0 being "not accurate" and 1 being "mostly accurate".\r\n        """\r\n\r\n        system_prompt = str.format(\r\n            SEARCH_QUERY_ACCURACY_TEMPLATE,\r\n            user_question=user_question,\r\n            chat_history=chat_history,\r\n            search_query=search_query,\r\n        )\r\n        return self.generate_score_and_reasons(system_prompt)\r\n\r\n    def search_query_conciseness_with_cot_reasons(\r\n        self, user_question: str, chat_history: list[str], search_query: str\r\n    ) -> float:\r\n        """Get the conciseness score for the search query generated\r\n\r\n        Usage:\r\n            ```python\r\n            search_query_conciseness_feedback = (\r\n                Feedback(provider.search_query_conciseness_with_cot_reasons, name="Search Query Conciseness")\r\n                .on(user_question=Select.RecordCalls.query.args["question"])\r\n                .on(chat_history=Select.RecordCalls.query.args["chat_history"])\r\n                .on(search_query=Select.RecordCalls.get_search_query.rets)\r\n            )\r\n\r\n        Args:\r\n            user_question (str): The user question for which the query is being generated\r\n            chat_history (list[str]): previous chat history\r\n            search_query (str): The search query generated by the system\r\n\r\n        Returns:\r\n            float: A value between 0 and 1. 0 being "not concise" and 1 being "mostly concise".\r\n        """\r\n\r\n        system_prompt = str.format(\r\n            SEARCH_QUERY_CONCISENESS_TEMPLATE,\r\n            user_question=user_question,\r\n            chat_history=chat_history,\r\n            search_query=search_query,\r\n        )\r\n        return self.generate_score_and_reasons(system_prompt)\n'})})]})}function d(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},28453:(e,r,n)=>{n.d(r,{R:()=>a,x:()=>i});var t=n(96540);const s={},o=t.createContext(s);function a(e){const r=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(o.Provider,{value:r},e.children)}}}]);