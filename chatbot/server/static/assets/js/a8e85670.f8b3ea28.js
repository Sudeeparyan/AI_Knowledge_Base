"use strict";(self.webpackChunksudeeparyan_knowledgebase=self.webpackChunksudeeparyan_knowledgebase||[]).push([[4635],{50252:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var s=t(74848),r=t(28453);const o={},a=void 0,i={id:"AI360/Agents/LangGraph/Key components",title:"Key components",description:"Stateful Graph",source:"@site/docs/AI360/Agents/LangGraph/Key components.md",sourceDirName:"AI360/Agents/LangGraph",slug:"/AI360/Agents/LangGraph/Key components",permalink:"/docs/AI360/Agents/LangGraph/Key components",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"AI360Sidebar",previous:{title:"Introduction",permalink:"/docs/AI360/Agents/LangGraph/Introduction"},next:{title:"Simple graph construction",permalink:"/docs/AI360/Agents/LangGraph/Simple graph construction"}},d={},l=[{value:"Stateful Graph",id:"stateful-graph",level:3},{value:"State",id:"state",level:3},{value:"Nodes",id:"nodes",level:3},{value:"Edges",id:"edges",level:3},{value:"Types of edges",id:"types-of-edges",level:3}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h3,{id:"stateful-graph",children:"Stateful Graph"}),"\n",(0,s.jsx)(n.p,{children:"LangGraph revolves around the concept of a stateful graph, where each node in the graph represents a step in your computation, and the graph maintains a state that is passed around and updated as the computation progresses."}),"\n",(0,s.jsx)(n.h3,{id:"state",children:"State"}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Learn more about ",(0,s.jsx)(n.a,{href:"https://langchain-ai.github.io/langgraph/concepts/low_level/#state",children:"State- Explanation"})]}),"\n"]})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"The State consists of the schema of the graph as well as reducer functions which specify how to apply updates to the state."}),"\n",(0,s.jsx)(n.li,{children:"State is the shared data structure that represents the current snapshot of your application. It can be any Python type, but is typically a TypedDict or Pydantic BaseModel."}),"\n",(0,s.jsx)(n.li,{children:"The State schema serves as the input schema for all Nodes and Edges in the graph."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"from typing_extensions import TypedDict\r\n\r\nclass State(TypedDict):\r\n  graph_state: str\n"})}),"\n",(0,s.jsx)(n.h3,{id:"nodes",children:"Nodes"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Node represents a function or a computation step. Nodes are designed to perform specific tasks, such as processing input, making decisions, or interacting with external APIs."}),"\n",(0,s.jsx)(n.li,{children:"Nodes are nothing but python functions."}),"\n",(0,s.jsx)(n.li,{children:"Python functions that encode the logic of your agents. They receive the current State as input, perform some computation or side-effect, and return an updated State."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:' def node_1(state):\r\n     print("---Node 1---")\r\n     return {"graph_state": state[\'graph_state\'] +" I am"}\r\n\r\n def node_2(state):\r\n     print("---Node 2---")\r\n     return {"graph_state": state[\'graph_state\'] +" happy!"}\r\n\r\n def node_3(state):\r\n     print("---Node 3---")\r\n     return {"graph_state": state[\'graph_state\'] +" sad!"}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"edges",children:"Edges"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Edges connect the nodes in your graph, defining the flow of computation."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"LangGraph supports conditional edges, allowing you to dynamically determine the next node to execute based on the current state of the graph."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Learn more about ",(0,s.jsx)(n.a,{href:"https://langchain-ai.github.io/langgraph/concepts/low_level/#edges",children:"Edges - explanation"})]}),"\n"]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import random\r\nfrom typing import Literal\r\n\r\ndef decide_mood(state) -> Literal["node_2", "node_3"]:\r\n    # Often, we will use state to decide on the next node to visit\r\n    user_input = state[\'graph_state\'] \r\n    # Here, let\'s just do a 50 / 50 split between nodes 2, 3\r\n    if random.random() < 0.5:\r\n        # 50% of the time, we return Node 2\r\n        return "node_2"\r\n    # 50% of the time, we return Node 3\r\n    return "node_3"\n'})}),"\n",(0,s.jsx)(n.h3,{id:"types-of-edges",children:"Types of edges"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Normal Edges"}),": Go directly from one node to the next."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Conditional Edges"}),": Call a function to determine which node(s) to go to next."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Entry Point"}),": Which node to call first when user input arrives."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Conditional Entry Point"}),": Call a function to determine which node(s) to call first when user input arrives."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>i});var s=t(96540);const r={},o=s.createContext(r);function a(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);